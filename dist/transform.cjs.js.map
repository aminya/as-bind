{"version":3,"file":"transform.cjs.js","sources":["../node_modules/.pnpm/assemblyscript@0.27.23/node_modules/assemblyscript/dist/transform.js","../transform.ts"],"sourcesContent":["export class Transform { /* stub */ };\n","import {\n  CommonFlags,\n  NodeKind,\n  ElementKind,\n  IdentifierExpression,\n  FunctionPrototype,\n  StringLiteralExpression,\n  Module,\n  Function,\n  DeclaredElement,\n  Type\n} from \"assemblyscript/dist/assemblyscript.js\";\nimport { Transform } from \"assemblyscript/dist/transform.js\";\nimport { TypeDef } from \"./lib/types\";\n\nfunction isInternalElement(element: DeclaredElement) {\n  return element.internalName.startsWith(\"~\");\n}\n\nfunction elementHasFlag(el: DeclaredElement, flag: number) {\n  return (el.flags & flag) != 0;\n}\n\nfunction typeName(type: Type) {\n  return type.getClass()?.internalName ?? type.toString();\n}\n\nfunction containingModule(func: Function) {\n  let container = func.parent;\n  // Only a module is it’s own parent\n  while (container !== container.parent) {\n    container = container.parent;\n  }\n  return container;\n}\n\nfunction getFunctionTypeDescriptor(func: Function) {\n  return {\n    returnType: typeName(func.signature.returnType),\n    parameters: func.signature.parameterTypes.map(parameter =>\n      typeName(parameter)\n    )\n  };\n}\n\nfunction extractTypeIds(type: Type) {\n  const result = {};\n  const clazz = type.getClass?.();\n  if (!clazz) {\n    return result;\n  }\n  result[clazz.internalName] = {\n    id: clazz.id,\n    byteSize: clazz.nextMemoryOffset\n  };\n  if (clazz.typeArguments) {\n    for (const subType of clazz.typeArguments) {\n      Object.assign(result, extractTypeIds(subType));\n    }\n  }\n  return result;\n}\n\nfunction extractTypeIdsFromFunction(func: Function) {\n  const result = {};\n  Object.assign(result, extractTypeIds(func.signature.returnType));\n  func.signature.parameterTypes.forEach(paramType =>\n    Object.assign(result, extractTypeIds(paramType))\n  );\n  return result;\n}\n\nconst SECTION_NAME = \"as-bind_bindings\";\n\nexport default class AsBindTransform extends Transform {\n  afterCompile(module: Module) {\n    const flatExportedFunctions = [\n      ...this.program.elementsByDeclaration.values()\n    ]\n      .filter(el => elementHasFlag(el, CommonFlags.ModuleExport))\n      .filter(el => !isInternalElement(el))\n      .filter(\n        el => el.declaration.kind === NodeKind.FunctionDeclaration\n      ) as FunctionPrototype[];\n    const flatImportedFunctions = [\n      ...this.program.elementsByDeclaration.values()\n    ]\n      .filter(el => elementHasFlag(el, CommonFlags.Declare))\n      .filter(el => !isInternalElement(el))\n      .filter(\n        v => v.declaration.kind === NodeKind.FunctionDeclaration\n      ) as FunctionPrototype[];\n\n    const typeIds: TypeDef[\"typeIds\"] = {};\n    const importedFunctions: TypeDef[\"importedFunctions\"] = {};\n    for (let importedFunction of flatImportedFunctions) {\n      // An imported function with no instances is an unused imported function.\n      // Skip it.\n      if (!importedFunction.instances) {\n        continue;\n      }\n      if (\n        importedFunction.instances.size > 1 ||\n        !importedFunction.instances.has(\"\")\n      ) {\n        throw Error(`Can’t import or export generic functions.`);\n      }\n\n      const iFunction = importedFunction.instances.get(\"\")!;\n\n      let external_module: string | undefined;\n      let external_name: string | undefined;\n\n      let decorators = iFunction.declaration.decorators;\n\n      if (decorators) {\n        for (let decorator of decorators) {\n          if ((decorator.name as IdentifierExpression).text !== \"external\")\n            continue;\n          if (!decorator.args) continue; // sanity check\n\n          if (decorator.args.length > 1) {\n            external_module = (decorator.args[0] as StringLiteralExpression)\n              .value;\n            external_name = (decorator.args[1] as StringLiteralExpression)\n              .value;\n          } else {\n            external_name = (decorator.args[0] as StringLiteralExpression)\n              .value;\n          }\n        }\n      }\n\n      // To know under what module name an imported function will be expected,\n      // we have to find the containing module of the given function, take the\n      // internal name (which is effectively the file path without extension)\n      // and only take the part after the last `/`\n      // (i.e. the file name without extension).\n      const moduleName =\n        external_module ||\n        containingModule(iFunction).internalName.split(\"/\").slice(-1)[0];\n      if (!importedFunctions.hasOwnProperty(moduleName)) {\n        importedFunctions[moduleName] = {};\n      }\n      let importedFunctionName = iFunction.name;\n      if (external_name) {\n        importedFunctionName = external_name;\n      } else if (\n        iFunction.parent &&\n        iFunction.parent.kind === ElementKind.Namespace\n      ) {\n        importedFunctionName = iFunction.parent.name + \".\" + iFunction.name;\n      }\n      importedFunctions[moduleName][importedFunctionName] =\n        getFunctionTypeDescriptor(iFunction);\n      Object.assign(typeIds, extractTypeIdsFromFunction(iFunction));\n    }\n    const exportedFunctions = {};\n    for (let exportedFunction of flatExportedFunctions) {\n      if (\n        exportedFunction.instances.size > 1 ||\n        !exportedFunction.instances.has(\"\")\n      ) {\n        throw Error(`Can’t import or export generic functions.`);\n      }\n      const eFunction = exportedFunction.instances.get(\"\");\n      exportedFunctions[eFunction.name] = getFunctionTypeDescriptor(eFunction);\n      Object.assign(typeIds, extractTypeIdsFromFunction(eFunction));\n    }\n\n    module.addCustomSection(\n      SECTION_NAME,\n      // @ts-ignore\n      new TextEncoder(\"utf8\").encode(\n        JSON.stringify({\n          typeIds,\n          importedFunctions,\n          exportedFunctions\n        })\n      )\n    );\n  }\n}\n"],"names":["Transform","isInternalElement","element","internalName","startsWith","elementHasFlag","el","flag","flags","typeName","type","getClass","toString","containingModule","func","container","parent","getFunctionTypeDescriptor","returnType","signature","parameters","parameterTypes","map","parameter","extractTypeIds","result","clazz","id","byteSize","nextMemoryOffset","typeArguments","subType","Object","assign","extractTypeIdsFromFunction","forEach","paramType","afterCompile","module","flatExportedFunctions","this","program","elementsByDeclaration","values","filter","declaration","kind","flatImportedFunctions","v","typeIds","importedFunctions","importedFunction","instances","size","has","Error","iFunction","get","external_module","external_name","decorators","decorator","name","text","args","length","value","moduleName","split","slice","hasOwnProperty","importedFunctionName","exportedFunctions","exportedFunction","eFunction","addCustomSection","TextEncoder","encode","JSON","stringify"],"mappings":"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","x_google_ignoreList":[0]}