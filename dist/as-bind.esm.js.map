{"version":3,"file":"as-bind.esm.js","sources":["../node_modules/.pnpm/@assemblyscript+loader@0.27.23/node_modules/@assemblyscript/loader/index.js","../lib/asbind-instance/type-converters.ts","../lib/asbind-instance/bind-function.ts","../lib/asbind-instance/asbind-instance.ts","../lib/asbind-instance/instantiate.ts","../lib/lib.ts"],"sourcesContent":["// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\n// const OBJECT_ID = 0;\nconst ARRAYBUFFER_ID = 1;\nconst STRING_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst STATICARRAY = 1 << 2;\n// const SET = 1 << 3;\n// const MAP = 1 << 4;\nconst VAL_ALIGN_OFFSET = 6;\n// const VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 11;\nconst VAL_FLOAT = 1 << 12;\n// const VAL_NULLABLE = 1 << 13;\nconst VAL_MANAGED = 1 << 14;\n// const KEY_ALIGN_OFFSET = 15;\n// const KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\n// const KEY_SIGNED = 1 << 20;\n// const KEY_FLOAT = 1 << 21;\n// const KEY_NULLABLE = 1 << 22;\n// const KEY_MANAGED = 1 << 23;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_BYTELENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst E_NO_EXPORT_TABLE   = \"Operation requires compiling with --exportTable\";\nconst E_NO_EXPORT_RUNTIME = \"Operation requires compiling with --exportRuntime\";\nconst F_NO_EXPORT_RUNTIME = () => { throw Error(E_NO_EXPORT_RUNTIME); };\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\n\nconst STRING_SMALLSIZE = 192; // break-even point in V8\nconst STRING_CHUNKSIZE = 1024; // mitigate stack overflow\nconst utf16 = new TextDecoder(\"utf-16le\", { fatal: true }); // != wtf16\n\n/** polyfill for Object.hasOwn */\nObject.hasOwn = Object.hasOwn || function(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n};\n\n/** Gets a string from memory. */\nfunction getStringImpl(buffer, ptr) {\n  let len = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2] >>> 1;\n  const wtf16 = new Uint16Array(buffer, ptr, len);\n  if (len <= STRING_SMALLSIZE) return String.fromCharCode(...wtf16);\n  try {\n    return utf16.decode(wtf16);\n  } catch {\n    let str = \"\", off = 0;\n    while (len - off > STRING_CHUNKSIZE) {\n      str += String.fromCharCode(...wtf16.subarray(off, off += STRING_CHUNKSIZE));\n    }\n    return str + String.fromCharCode(...wtf16.subarray(off));\n  }\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const extendedExports = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(msg, file, line, colm) {\n    const memory = extendedExports.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(`abort: ${getString(memory, msg)} at ${getString(memory, file)}:${line}:${colm}`);\n  };\n  env.trace = env.trace || function trace(msg, n, ...args) {\n    const memory = extendedExports.memory || env.memory;\n    console.log(`trace: ${getString(memory, msg)}${n ? \" \" : \"\"}${args.slice(0, n).join(\", \")}`);\n  };\n  env.seed = env.seed || Date.now;\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return extendedExports;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(extendedExports, instance) {\n  const exports = instance.exports;\n  const memory = exports.memory;\n  const table = exports.table;\n  const __new = exports.__new || F_NO_EXPORT_RUNTIME;\n  const __pin = exports.__pin || F_NO_EXPORT_RUNTIME;\n  const __unpin = exports.__unpin || F_NO_EXPORT_RUNTIME;\n  const __collect = exports.__collect || F_NO_EXPORT_RUNTIME;\n  const __rtti_base = exports.__rtti_base;\n  const getTypeinfoCount = __rtti_base ? arr => arr[__rtti_base >>> 2] : F_NO_EXPORT_RUNTIME;\n\n  extendedExports.__new = __new;\n  extendedExports.__pin = __pin;\n  extendedExports.__unpin = __unpin;\n  extendedExports.__collect = __collect;\n\n  /** Gets the runtime type info for the given id. */\n  function getTypeinfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    if ((id >>>= 0) >= getTypeinfoCount(U32)) throw Error(`invalid id: ${id}`);\n    return U32[(__rtti_base + 4 >>> 2) + id];\n  }\n\n  /** Gets and validates runtime type info for the given id for array like objects */\n  function getArrayInfo(id) {\n    const info = getTypeinfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY | STATICARRAY))) throw Error(`not an array: ${id}, flags=${info}`);\n    return info;\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  // function getKeyAlign(info) {\n  //   return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  // }\n\n  /** Allocates a new string in the module's memory and returns its pointer. */\n  function __newString(str) {\n    if (str == null) return 0;\n    const length = str.length;\n    const ptr = __new(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (let i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  extendedExports.__newString = __newString;\n\n  /** Allocates a new ArrayBuffer in the module's memory and returns its pointer. */\n  function __newArrayBuffer(buf) {\n    if (buf == null) return 0;\n    const bufview = new Uint8Array(buf);\n    const ptr = __new(bufview.length, ARRAYBUFFER_ID);\n    const U8 = new Uint8Array(memory.buffer);\n    U8.set(bufview, ptr);\n    return ptr;\n  }\n\n  extendedExports.__newArrayBuffer = __newArrayBuffer;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    if (!ptr) return null;\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(`not a string: ${ptr}`);\n    return getStringImpl(buffer, ptr);\n  }\n\n  extendedExports.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(`unsupported align: ${alignLog2}`);\n  }\n\n  /** Allocates a new array in the module's memory and returns its pointer. */\n  function __newArray(id, valuesOrCapacity = 0) {\n    const input = valuesOrCapacity;\n    const info = getArrayInfo(id);\n    const align = getValueAlign(info);\n    const isArrayLike = typeof input !== \"number\";\n    const length = isArrayLike ? input.length : input;\n    const buf = __new(length << align, info & STATICARRAY ? id : ARRAYBUFFER_ID);\n    let result;\n    if (info & STATICARRAY) {\n      result = buf;\n    } else {\n      __pin(buf);\n      const arr = __new(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n      __unpin(buf);\n      const U32 = new Uint32Array(memory.buffer);\n      U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = buf;\n      U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n      U32[arr + ARRAYBUFFERVIEW_BYTELENGTH_OFFSET >>> 2] = length << align;\n      if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n      result = arr;\n    }\n    if (isArrayLike) {\n      const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n      const start = buf >>> align;\n      if (info & VAL_MANAGED) {\n        for (let i = 0; i < length; ++i) {\n          view[start + i] = input[i];\n        }\n      } else {\n        view.set(input, start);\n      }\n    }\n    return result;\n  }\n\n  extendedExports.__newArray = __newArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getArrayInfo(id);\n    const align = getValueAlign(info);\n    let buf = info & STATICARRAY\n      ? arr\n      : U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);\n  }\n\n  extendedExports.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  extendedExports.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  extendedExports.__getArrayBuffer = __getArrayBuffer;\n\n  /** Gets a function from poiner which contain table's index. */\n  function __getFunction(ptr) {\n    if (!table) throw Error(E_NO_EXPORT_TABLE);\n    const index = new Uint32Array(memory.buffer)[ptr >>> 2];\n    return table.get(index);\n  }\n\n  extendedExports.__getFunction = __getFunction;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    return new Type(\n      buffer,\n      U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2],\n      U32[ptr + ARRAYBUFFERVIEW_BYTELENGTH_OFFSET >>> 2] >>> alignLog2\n    );\n  }\n\n  /** Attach a set of get TypedArray and View functions to the exports. */\n  function attachTypedArrayFunctions(ctor, name, align) {\n    extendedExports[`__get${name}`] = getTypedArray.bind(null, ctor, align);\n    extendedExports[`__get${name}View`] = getTypedArrayView.bind(null, ctor, align);\n  }\n\n  [\n    Int8Array,\n    Uint8Array,\n    Uint8ClampedArray,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array\n  ].forEach(ctor => {\n    attachTypedArrayFunctions(ctor, ctor.name, 31 - Math.clz32(ctor.BYTES_PER_ELEMENT));\n  });\n\n  if (BIGINT) {\n    [BigUint64Array, BigInt64Array].forEach(ctor => {\n      attachTypedArrayFunctions(ctor, ctor.name.slice(3), 3);\n    });\n  }\n\n  // Pull basic exports to extendedExports so code in preInstantiate can use them\n  extendedExports.memory = extendedExports.memory || memory;\n  extendedExports.table  = extendedExports.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(exports, extendedExports);\n}\n\nfunction isResponse(src) {\n  return typeof Response !== \"undefined\" && src instanceof Response;\n}\n\nfunction isModule(src) {\n  return src instanceof WebAssembly.Module;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nexport async function instantiate(source, imports = {}) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  const module = isModule(source) ? source : await WebAssembly.compile(source);\n  const extended = preInstantiate(imports);\n  const instance = await WebAssembly.instantiate(module, imports);\n  const exports = postInstantiate(extended, instance);\n  return { module, instance, exports };\n}\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nexport function instantiateSync(source, imports = {}) {\n  const module = isModule(source) ? source : new WebAssembly.Module(source);\n  const extended = preInstantiate(imports);\n  const instance = new WebAssembly.Instance(module, imports);\n  const exports = postInstantiate(extended, instance);\n  return { module, instance, exports };\n}\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nexport async function instantiateStreaming(source, imports = {}) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  const extended = preInstantiate(imports);\n  const result = await WebAssembly.instantiateStreaming(source, imports);\n  const exports = postInstantiate(extended, result.instance);\n  return { ...result, exports };\n}\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nexport function demangle(exports, extendedExports = {}) {\n  const setArgumentsLength = exports[\"__argumentsLength\"]\n    ? length => { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || (() => { /* nop */ });\n  for (let internalName of Object.keys(exports)) {\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = extendedExports;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.hasOwn(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      const className = name.substring(0, hash);\n      const classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        const ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf() { return this[THIS]; }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.hasOwn(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get() { return getter(this[THIS]); },\n            set(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = function(...args) {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.hasOwn(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return extendedExports;\n}\n\nexport default {\n  instantiate,\n  instantiateSync,\n  instantiateStreaming,\n  demangle\n};\n","import AsbindInstance from \"./asbind-instance\";\n\n// Converts web platform names for the different ArrayBufferViews\n// to the names that ASC understands. Currently, that only means\n// to cut off the `Big` in `BigInt64Array`.\nconst stdlibTypedArrayPrefix = \"~lib/typedarray/\";\nfunction normalizeArrayBufferViewTypeName(typeName: string) {\n  // Don’t do anything if this is not a stdlib type.\n  if (!typeName.startsWith(stdlibTypedArrayPrefix)) {\n    return typeName;\n  }\n  typeName = typeName.slice(stdlibTypedArrayPrefix.length);\n  if (typeName.startsWith(\"Big\")) {\n    // Slice off `Big` as the loader doesn’t have that prefix.\n    typeName = typeName.slice(3);\n  }\n  return typeName;\n}\n\nfunction nop(asbindInstance: AsbindInstance, value: any, typeName: string) {\n  return value;\n}\n\nfunction getString(\n  asbindInstance: AsbindInstance,\n  value: any,\n  typeName: string\n) {\n  return asbindInstance.exports.__getString(value);\n}\n\nfunction putString(\n  asbindInstance: AsbindInstance,\n  value: any,\n  typeName: string\n) {\n  return asbindInstance.exports.__newString(value);\n}\n\nfunction getArrayBuffer(\n  asbindInstance: AsbindInstance,\n  value: any,\n  typeName: string\n) {\n  return asbindInstance.exports.__getArrayBuffer(value);\n}\n\nfunction putArrayBuffer(\n  asbindInstance: AsbindInstance,\n  value: any,\n  typeName: string\n) {\n  const ptr = asbindInstance.exports.__new(\n    value.byteLength,\n    asbindInstance.getTypeId(typeName)\n  );\n  new Uint8Array(\n    asbindInstance.exports.memory.buffer,\n    ptr,\n    value.byteLength\n  ).set(new Uint8Array(value));\n  return ptr;\n}\n\nfunction getArrayBufferView(\n  asbindInstance: AsbindInstance,\n  value: any,\n  typeName: string\n) {\n  return asbindInstance.exports[\n    `__get${normalizeArrayBufferViewTypeName(typeName)}View`\n  ](value);\n}\nfunction putArrayBufferView(\n  asbindInstance: AsbindInstance,\n  value: any,\n  typeName: string\n) {\n  return asbindInstance.exports.__newArray(\n    asbindInstance.getTypeId(typeName),\n    value\n  );\n}\n\nconst stdlibArray = \"~lib/array/Array\";\nfunction arrayInnerType(typeName: string) {\n  if (!typeName.startsWith(stdlibArray)) {\n    throw Error(`${JSON.stringify(typeName)} is not an array type`);\n  }\n  // Cut off stdlib path + generic angle brackets.\n  return typeName.slice(`${stdlibArray}<`.length, -1);\n}\n\nfunction getArray(\n  asbindInstance: AsbindInstance,\n  value: any,\n  typeName: string\n) {\n  const innerTypeName = arrayInnerType(typeName);\n  const innerTypeConverter = getConverterForType(innerTypeName);\n  const rawArray = asbindInstance.exports.__getArray(value);\n  return rawArray.map(v =>\n    innerTypeConverter.ascToJs(asbindInstance, v, innerTypeName)\n  );\n}\n\nfunction putArray(\n  asbindInstance: AsbindInstance,\n  value: any,\n  typeName: string\n) {\n  const innerTypeName = arrayInnerType(typeName);\n  const innerTypeConverter = getConverterForType(innerTypeName);\n  const convertedValues = value.map(v =>\n    innerTypeConverter.jsToAsc(asbindInstance, v, innerTypeName)\n  );\n  return asbindInstance.exports.__newArray(\n    asbindInstance.getTypeId(typeName),\n    convertedValues\n  );\n}\n\nexport interface Converter {\n  ascToJs(asbindInstance: AsbindInstance, value: any, typeName: string): any;\n  jsToAsc(asbindInstance: AsbindInstance, value: any, typeName: string): any;\n}\n\nexport const converters = new Map<string | RegExp, Converter>([\n  [\"void\", { ascToJs: nop, jsToAsc: nop }],\n  // Technically this matches types that don’ exist (like f8),\n  // but since those can only appear if the compiler accepts them,\n  // it seems unlikely for that to be a problem.\n  [\n    /^(i|u|f)(8|16|32|64)|[ui]size|bool|externref$/,\n    { ascToJs: nop, jsToAsc: nop }\n  ],\n  [\"~lib/string/String\", { ascToJs: getString, jsToAsc: putString }],\n  [\n    \"~lib/typedarray/Int8Array\",\n    { ascToJs: getArrayBufferView, jsToAsc: putArrayBufferView }\n  ],\n  [\n    \"~lib/typedarray/Int16Array\",\n    { ascToJs: getArrayBufferView, jsToAsc: putArrayBufferView }\n  ],\n  [\n    \"~lib/typedarray/Int32Array\",\n    { ascToJs: getArrayBufferView, jsToAsc: putArrayBufferView }\n  ],\n  [\n    \"~lib/typedarray/Uint8Array\",\n    { ascToJs: getArrayBufferView, jsToAsc: putArrayBufferView }\n  ],\n  [\n    \"~lib/typedarray/Uint16Array\",\n    { ascToJs: getArrayBufferView, jsToAsc: putArrayBufferView }\n  ],\n  [\n    \"~lib/typedarray/Uint32Array\",\n    { ascToJs: getArrayBufferView, jsToAsc: putArrayBufferView }\n  ],\n  [\n    \"~lib/typedarray/Int64Array\",\n    { ascToJs: getArrayBufferView, jsToAsc: putArrayBufferView }\n  ],\n  [\n    \"~lib/typedarray/Uint64Array\",\n    { ascToJs: getArrayBufferView, jsToAsc: putArrayBufferView }\n  ],\n  [\n    \"~lib/typedarray/Uint8ClampedArray\",\n    { ascToJs: getArrayBufferView, jsToAsc: putArrayBufferView }\n  ],\n  [\n    \"~lib/typedarray/Float32Array\",\n    { ascToJs: getArrayBufferView, jsToAsc: putArrayBufferView }\n  ],\n  [\n    \"~lib/typedarray/Float64Array\",\n    { ascToJs: getArrayBufferView, jsToAsc: putArrayBufferView }\n  ],\n  [\n    \"~lib/arraybuffer/ArrayBuffer\",\n    { ascToJs: getArrayBuffer, jsToAsc: putArrayBuffer }\n  ],\n  [/^~lib\\/array\\/Array<.+>$/, { ascToJs: getArray, jsToAsc: putArray }]\n]);\n\nconst warned = new Set<string>();\nexport function getConverterForType(typeName: string): Converter {\n  for (const [matcher, converter] of converters) {\n    if (typeof matcher === \"string\") {\n      if (matcher === typeName) {\n        return converter;\n      }\n      continue;\n    } else if (matcher.test(typeName)) {\n      return converter;\n    }\n  }\n  if (!warned.has(typeName)) {\n    console.warn(\n      `No converter for ${JSON.stringify(typeName)}, using pass-through`\n    );\n    warned.add(typeName);\n  }\n  return { ascToJs: nop, jsToAsc: nop };\n}\n\nexport function getAscToJsConverterForType(typeName: string) {\n  return getConverterForType(typeName).ascToJs;\n}\n\nexport function getJsToAscConverterForType(typeName: string) {\n  return getConverterForType(typeName).jsToAsc;\n}\n","import { TypeDefFn } from \"../types\";\nimport AsbindInstance from \"./asbind-instance\";\n\nimport {\n  getAscToJsConverterForType,\n  getJsToAscConverterForType\n} from \"./type-converters\";\n\nfunction getFunctionFromKeyPath(baseObject, keys) {\n  let result = baseObject;\n  for (const key of keys) {\n    result = result?.[key];\n  }\n  return result;\n}\n\nexport function bindImportFunction(\n  asbindInstance: AsbindInstance,\n  importedFunction: Function,\n  importedFunctionDescriptor: TypeDefFn\n) {\n  // Grab type converter functions according to the type descriptor\n  const argumentConverterFunctions = importedFunctionDescriptor.parameters.map(\n    getAscToJsConverterForType\n  );\n  const returnValueConverterFunction = getJsToAscConverterForType(\n    importedFunctionDescriptor.returnType\n  );\n\n  // Create a wrapper function that applies the correct converter function to arguments and\n  // return value respectively.\n  return function (...args) {\n    if (args.length != argumentConverterFunctions.length) {\n      throw Error(\n        `Expected ${argumentConverterFunctions.length} arguments, got ${args.length}`\n      );\n    }\n    const newArgs = args.map((v, i) =>\n      argumentConverterFunctions[i](\n        asbindInstance,\n        v,\n        importedFunctionDescriptor.parameters[i]\n      )\n    );\n    const result = importedFunction(...newArgs);\n    return returnValueConverterFunction(\n      asbindInstance,\n      result,\n      importedFunctionDescriptor.returnType\n    );\n  };\n}\n\n// Function that takes in an asbind instance, and the key to the export function on the\n// abindInstance.exports object, to be wrapped and then re-assigned to the asbindInstance.exports.\nexport function bindExportFunction(\n  asbindInstance: AsbindInstance,\n  exportedFunction: Function,\n  exportedFunctionDescriptor: TypeDefFn\n) {\n  // Grab type converter functions according to the type descriptor\n  const argumentConverterFunctions = exportedFunctionDescriptor.parameters.map(\n    getJsToAscConverterForType\n  );\n  const returnValueConverterFunction = getAscToJsConverterForType(\n    exportedFunctionDescriptor.returnType\n  );\n\n  // Create a wrapper function that applies the correct converter function to arguments and\n  // return value respectively.\n  return (...args) => {\n    if (args.length != argumentConverterFunctions.length) {\n      throw Error(\n        `Expected ${argumentConverterFunctions.length} arguments, got ${args.length}`\n      );\n    }\n    // The conversion function of the _next_ parameter could potentially\n    // trigger GC and collect the previous parameter before we even invoke\n    // the actual function. That’s bad! We’ll pin all non-primitive parameters before invocation\n    // and unpin them after.\n    const pinnedArgs = [];\n    const newArgs = args.map((originalParameter, i) => {\n      const convertedParameter = argumentConverterFunctions[i](\n        asbindInstance,\n        originalParameter,\n        exportedFunctionDescriptor.parameters[i]\n      );\n      if (convertedParameter !== originalParameter) {\n        asbindInstance.exports.__pin(convertedParameter);\n        pinnedArgs.push(convertedParameter);\n      }\n      return convertedParameter;\n    });\n    const result = exportedFunction(...newArgs);\n    pinnedArgs.forEach(arg => asbindInstance.exports.__unpin(arg));\n    return returnValueConverterFunction(\n      asbindInstance,\n      result,\n      exportedFunctionDescriptor.returnType\n    );\n  };\n}\n","// Class for asbind instances\nimport { asbindInstantiate, asbindInstantiateSync } from \"./instantiate\";\nimport { bindImportFunction, bindExportFunction } from \"./bind-function\";\nimport {\n  TypeDef,\n  WebAssemblyModuleStreaming,\n  WebAssemblyModuleSync,\n  WebAssemblyLoaderResult\n} from \"../types\";\n\nimport { ASUtil } from \"@assemblyscript/loader\";\n\nconst SECTION_NAME = \"as-bind_bindings\";\n\n// Basically a deep-copy, but can be limited in levels.\nfunction copyObject<T>(obj: T, { depth = Number.POSITIVE_INFINITY } = {}): T {\n  if (depth <= 0 || !obj || typeof obj !== \"object\") {\n    return obj;\n  }\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, val]) => [\n      key,\n      copyObject(val, { depth: depth - 1 })\n    ])\n  ) as T;\n}\n\nasync function compileStreaming(source: WebAssemblyModuleStreaming) {\n  source = await Promise.resolve(source);\n  if (typeof Response !== \"undefined\" && source instanceof Response) {\n    if (WebAssembly.compileStreaming) {\n      return WebAssembly.compileStreaming(source);\n    }\n    source = await source.arrayBuffer();\n  }\n\n  return WebAssembly.compile(source as BufferSource);\n}\n\nfunction extractTypeDescriptor(module: WebAssembly.Module): TypeDef {\n  const sections = WebAssembly.Module.customSections(module, SECTION_NAME);\n  const str = new TextDecoder(\"utf8\").decode(new Uint8Array(sections[0]));\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    throw Error(`Couldn’t decode type descriptor: ${e.message}`);\n  }\n}\n\nexport default class AsbindInstance {\n  exports: Record<string, never> | ASUtil = {};\n  importObject: WebAssembly.Imports = {};\n  typeDescriptor: TypeDef;\n  module: WebAssembly.Module;\n  loadedModule: WebAssemblyLoaderResult;\n\n  getTypeId(typeName: string) {\n    if (typeName in this.typeDescriptor.typeIds) {\n      return this.typeDescriptor.typeIds[typeName].id;\n    }\n    throw Error(`Unknown type ${JSON.stringify(typeName)}`);\n  }\n\n  getTypeSize(typeName: string) {\n    if (typeName in this.typeDescriptor.typeIds) {\n      return this.typeDescriptor.typeIds[typeName].byteSize;\n    }\n    throw Error(`Unknown type ${JSON.stringify(typeName)}`);\n  }\n\n  _validate() {\n    if (\n      !WebAssembly.Module.exports(this.module).find(exp => exp.name === \"__new\")\n    ) {\n      throw Error(\n        \"The AssemblyScript wasm module was not built with --exportRuntime, which is required.\"\n      );\n    }\n    if (\n      WebAssembly.Module.customSections(this.module, SECTION_NAME).length !== 1\n    ) {\n      throw new Error(\n        \"The AssemblyScript wasm module was not built with the as-bind transform.\"\n      );\n    }\n  }\n\n  async _instantiate(\n    source: WebAssemblyModuleStreaming,\n    importObject: WebAssembly.Imports\n  ) {\n    this.module = await compileStreaming(source);\n\n    this._validate();\n    this.typeDescriptor = extractTypeDescriptor(this.module);\n    this._instantiateBindImportFunctions(importObject);\n    // Instantiate the module through the loader\n    this.loadedModule = await asbindInstantiate(this.module, this.importObject);\n    this._instantiateBindUnboundExports();\n  }\n\n  _instantiateSync(\n    source: WebAssemblyModuleSync,\n    importObject: WebAssembly.Imports\n  ) {\n    this.module = new WebAssembly.Module(source);\n\n    this._validate();\n    this.typeDescriptor = extractTypeDescriptor(this.module);\n    this._instantiateBindImportFunctions(importObject);\n    this.loadedModule = asbindInstantiateSync(this.module, this.importObject);\n    this._instantiateBindUnboundExports();\n  }\n\n  _instantiateBindImportFunctions(importObject: WebAssembly.Imports) {\n    this.importObject = copyObject(importObject, { depth: 2 });\n\n    for (const [moduleName, moduleDescriptor] of Object.entries(\n      this.typeDescriptor.importedFunctions\n    )) {\n      for (const [importedFunctionName, descriptor] of Object.entries(\n        moduleDescriptor\n      )) {\n        this.importObject[moduleName][\n          `__asbind_unbound_${importedFunctionName}`\n        ] = importObject[moduleName][importedFunctionName];\n        this.importObject[moduleName][importedFunctionName] =\n          bindImportFunction(\n            this,\n            importObject[moduleName][importedFunctionName] as Function,\n            descriptor\n          );\n      }\n    }\n  }\n\n  _instantiateBindUnboundExports() {\n    // Wrap appropriate the appropriate export functions\n    const unboundExports = this.loadedModule.exports;\n    this.exports = copyObject(unboundExports, { depth: 1 });\n\n    for (const [exportedFunctionName, descriptor] of Object.entries(\n      this.typeDescriptor.exportedFunctions\n    )) {\n      this.exports[exportedFunctionName] = bindExportFunction(\n        this,\n        unboundExports[exportedFunctionName],\n        descriptor\n      );\n    }\n  }\n}\n","// Wrapper around the loader instantiate\nimport loader from \"@assemblyscript/loader\";\n\nimport { WebAssemblyLoaderResult } from \"../types\";\n\nexport async function asbindInstantiate(\n  module: WebAssembly.Module,\n  importObject: WebAssembly.Imports\n): Promise<WebAssemblyLoaderResult> {\n  return loader.instantiate(module, importObject);\n}\n\nexport function asbindInstantiateSync(\n  module: WebAssembly.Module,\n  importObject: WebAssembly.Imports\n): WebAssemblyLoaderResult {\n  return loader.instantiateSync(module, importObject);\n}\n","import { version as packVersion } from \"../package.json\";\nimport AsbindInstance from \"./asbind-instance/asbind-instance\";\nexport { converters } from \"./asbind-instance/type-converters\";\n\nimport { WebAssemblyModuleStreaming, WebAssemblyModuleSync } from \"./types\";\n\nexport const version: string = packVersion;\n\nexport async function instantiate(\n  source: WebAssemblyModuleStreaming,\n  importObject: WebAssembly.Imports\n) {\n  let asbindInstance = new AsbindInstance();\n  await asbindInstance._instantiate(source, importObject);\n  return asbindInstance;\n}\n\nexport function instantiateSync(\n  source: WebAssemblyModuleSync,\n  importObject: WebAssembly.Imports\n) {\n  let asbindInstance = new AsbindInstance();\n  asbindInstance._instantiateSync(source, importObject);\n  return asbindInstance;\n}\n"],"names":["ID_OFFSET","SIZE_OFFSET","ARRAYBUFFER_ID","STRING_ID","ARRAYBUFFERVIEW","ARRAY","STATICARRAY","VAL_ALIGN_OFFSET","VAL_SIGNED","VAL_FLOAT","VAL_MANAGED","ARRAYBUFFERVIEW_BUFFER_OFFSET","ARRAYBUFFERVIEW_DATASTART_OFFSET","ARRAYBUFFERVIEW_BYTELENGTH_OFFSET","ARRAYBUFFERVIEW_SIZE","ARRAY_LENGTH_OFFSET","ARRAY_SIZE","E_NO_EXPORT_TABLE","F_NO_EXPORT_RUNTIME","Error","BIGINT","BigUint64Array","THIS","Symbol","STRING_SMALLSIZE","STRING_CHUNKSIZE","utf16","TextDecoder","fatal","getStringImpl","buffer","ptr","len","Uint32Array","wtf16","Uint16Array","String","fromCharCode","decode","str","off","subarray","preInstantiate","imports","extendedExports","getString","memory","env","abort","msg","file","line","colm","trace","n","args","console","log","slice","join","seed","Date","now","Math","postInstantiate","instance","exports","table","__new","__pin","__unpin","__collect","__rtti_base","getTypeinfoCount","arr","getArrayInfo","id","info","U32","getTypeinfo","getValueAlign","clz32","getView","alignLog2","signed","float","Float32Array","Float64Array","Int8Array","Uint8Array","Int16Array","Int32Array","BigInt64Array","__getArrayView","align","buf","length","getTypedArray","Type","getTypedArrayView","attachTypedArrayFunctions","ctor","name","bind","__newString","U16","i","p","charCodeAt","__newArrayBuffer","bufview","set","__getString","__newArray","valuesOrCapacity","input","isArrayLike","result","view","start","__getArray","out","Array","__getArrayBuffer","__getFunction","index","get","Uint8ClampedArray","forEach","BYTES_PER_ELEMENT","demangle","isResponse","src","Response","isModule","WebAssembly","Module","async","instantiate","source","instantiateStreaming","module","compile","extended","arrayBuffer","setArgumentsLength","value","internalName","Object","keys","elem","parts","split","curr","part","shift","hasOwn","hash","indexOf","className","substring","classElem","prototype","wrap","constructor","valueOf","this","thisValue","create","writable","getOwnPropertyNames","defineProperty","getOwnPropertyDescriptor","test","getter","replace","setter","enumerable","original","obj","prop","hasOwnProperty","call","loader","Instance","stdlibTypedArrayPrefix","nop","asbindInstance","typeName","getArrayBufferView","startsWith","normalizeArrayBufferViewTypeName","putArrayBufferView","getTypeId","stdlibArray","arrayInnerType","JSON","stringify","converters","Map","ascToJs","jsToAsc","byteLength","innerTypeName","innerTypeConverter","getConverterForType","map","v","convertedValues","warned","Set","matcher","converter","has","warn","add","getAscToJsConverterForType","getJsToAscConverterForType","bindImportFunction","importedFunction","importedFunctionDescriptor","argumentConverterFunctions","parameters","returnValueConverterFunction","returnType","newArgs","bindExportFunction","exportedFunction","exportedFunctionDescriptor","pinnedArgs","originalParameter","convertedParameter","push","arg","SECTION_NAME","copyObject","depth","Number","POSITIVE_INFINITY","fromEntries","entries","key","val","extractTypeDescriptor","sections","customSections","parse","e","message","AsbindInstance","importObject","typeDescriptor","loadedModule","typeIds","getTypeSize","byteSize","_validate","find","exp","_instantiate","Promise","resolve","compileStreaming","_instantiateBindImportFunctions","asbindInstantiate","_instantiateBindUnboundExports","_instantiateSync","instantiateSync","asbindInstantiateSync","moduleName","moduleDescriptor","importedFunctions","importedFunctionName","descriptor","unboundExports","exportedFunctionName","exportedFunctions","version"],"mappings":"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","x_google_ignoreList":[0]}